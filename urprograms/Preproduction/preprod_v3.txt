 Program
   Init Variables
   BeforeStart
     Script: readme.script
     Config
       'Printing Properties'
       clearance≔0.04
       ramp_dist≔0.1
       trigger_range≔0.003
       L2R_trig_dist≔0.01
       R2L_trig_dist≔0.058
       'The tcp rotation components relative to stack'
       stack_rx≔0
       stack_ry≔-d2r(180)
       stack_rz≔0
       'Reference Frame Tuning'
       box_to_pa_XY≔p[0,0,0,0,0,0]
       stack_a_to_ref≔p[0,0,0,0,0,0]
       stack_b_to_ref≔p[0,0,0,0,0,0]
     Config Static
       'Physical Properties'
       print_width≔0.04
       printer_width≔0.125
       'Task Enumeration'
       TE_L2R≔1
       TE_R2L≔2
     Config Calcs
       pa_x_clear≔(print_width+printer_width)/2
       runover≔pa_x_clear+ramp_dist
     Restart Checks
       tasks_equal≔task≟current_task
       tasks_printing≔task≠0 and current_task≠0 print_enable
       restart_task≔start_continue and ( not tasks_equal) and tasks_printing
       resume_task≔start_continue and tasks_equal and tasks_printing
       print_enable≔ False 
     Keep current pos as home
       sp≔get_actual_joint_positions()
       MoveJ
         sp
     Reset bits
       Set task_done=Off
       Set task_active=Off
       Set current_task=0
       Set moving_home=Off
       Set homed=Off
   Robot Program
     If gantry_in_pos_a or gantry_in_pos_b
       If cancel_home
         Call PreTask
         Call MoveHome
       ElseIf task≟TE_L2R or task≟TE_R2L
         Call PreTask
         Call StartTask
         Call SetWaypoints
         Call SanitiseInputs
         Call MoveWaypoints
         Call FinishTask
   PreTask
     If  not (gantry_in_pos_a xor gantry_in_pos_b)
       Popup: Err: Gantry not in pos
       Halt
     ElseIf gantry_in_pos_a
       reference≔pose_add(stack_b, stack_b_to_ref)
     ElseIf gantry_in_pos_b
       reference≔pose_add(stack_a, stack_a_to_ref)
     'Where is the miminimum Z relative to current pos'
     vision_pos_ex≔pose_trans(pose_inv(reference), get_actual_tcp_pose())
     vision_pos_ex≔pose_add(vision_pos_ex, p[0, 0, 2*clearance + z_min - vision_pos_ex[2], 0, 0, 0])
     CLEAR≔pose_trans(reference, vision_pos_ex)
   MoveHome
     Set current_task=0
     Set task_done=Off
     Set task_active=Off
     If  not homed
       Set moving_home= True 
       MoveL
         home
           Until (reached_waypoint)
             Set homed=On
       Set moving_home= False 
   StartTask
     Set current_task=task
     Set task_active=On
   SetWaypoints
     Set Ordering
       B2≔p[X2, Y, Z, 0, 0, 0]
       If current_task≟TE_L2R
         'Left to right (+ive)'
         xm≔1
         B1≔p[X1, Y, Z, 0, 0, 0]
         B3≔p[X3, Y, Z, 0, 0, 0]
         trigger_offset≔pa_x_clear+L2R_trig_dist
       ElseIf current_task≟TE_R2L
         'Right to left (-ive)'
         xm≔-1
         B1≔p[X3, Y, Z, 0, 0, 0]
         B3≔p[X1, Y, Z, 0, 0, 0]
         trigger_offset≔pa_x_clear+R2L_trig_dist
     Print Area Vars
       'Move the print areas relative to given box'
       PA1≔pose_add(B1, box_to_pa_XY)
       PA2≔pose_add(B2, box_to_pa_XY)
       PA3≔pose_add(B3, box_to_pa_XY)
     Calculate Waypoints
       'xm represents with flow, -xm represents against flow'
       PA1_EN≔pose_add(PA1, p[-runover*xm, 0, clearance, stack_rx, stack_ry, stack_rz])
       PA3_EX≔pose_add(PA3, p[+runover*xm, 0, clearance, stack_rx, stack_ry, stack_rz])
       'Rotation?'
       APPROACH≔pose_add(PA1_EN, p[0, 0, 2*clearance + z_min - PA1_EN[2], 0, 0, 0])
     Reference Base
       PA1_EN≔pose_trans(reference, PA1_EN)
       PA3_EX≔pose_trans(reference, PA3_EX)
       APPROACH≔pose_trans(reference, APPROACH)
   SanitiseInputs
     Comment
   MoveWaypoints
     'Position before the move'
     If homed
       MoveL
         Set homed= False 
         APPROACH
           Until (expression)
         PA1_EN
           Until (expression)
     ElseIf resume_task
       'Resume from current position'
       Set homed= False 
     ElseIf last_task≟TE_L2R and current_task≟TE_R2L and  not restart_task
       'L2R -> R2L'
       Set homed= False 
       MoveL
         PA1_EN
           Until (expression)
     Else
       MoveL
         Set homed= False 
         CLEAR
           Until (expression)
         APPROACH
           Until (expression)
         PA1_EN
           Until (expression)
     'Move Across'
     MoveL
       print_enable≔ True 
       PA3_EX
         Until (expression)
       print_enable≔ False 
     resume_task≔ False 
   FinishTask
     'Acknowledgement sequence with PLC'
     last_task≔current_task
     Set task_active=Off
     Set task_done=On
     Wait task≟0 or cancel_home
     Set current_task=0
     Set task_done=Off
   Thread_1
     'Monitors X position for printing'
     If print_enable
       vision_pos≔pose_trans(pose_inv(reference), get_actual_tcp_pose())
       print1≔norm(vision_pos[0] - (PA1[0]-xm*(trigger_offset-trigger_range/2))) ≤ trigger_range
       print2≔norm(vision_pos[0] - (PA2[0]-xm*(trigger_offset-trigger_range/2))) ≤ trigger_range
       print3≔norm(vision_pos[0] - (PA3[0]-xm*(trigger_offset-trigger_range/2))) ≤ trigger_range
       If print1 or print2 or print3
         Set printing=HI:Pulse 0.05
         Set CO[0]=HI:Pulse 0.05
     sync()
