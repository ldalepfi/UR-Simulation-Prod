def prod_v5():
  set_tcp(p[-0.12,-0.0155,0.171,0.0,0.0,0.0])
  set_payload(1.75, [-0.1, -0.04, 0.01])
  set_gravity([0.0, -1.2026031567627009E-15, -9.82])
  set_safety_mode_transition_hardness(1)
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  step_count_ef762551_41ea_40d1_8478_a90c35c90e93 = 0.0
  thread Step_Counter_Thread_98ca54c5_9401_4358_ac37_d1ac7913db49():
    while (True):
      step_count_ef762551_41ea_40d1_8478_a90c35c90e93 = step_count_ef762551_41ea_40d1_8478_a90c35c90e93 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_98ca54c5_9401_4358_ac37_d1ac7913db49()
  set_tool_voltage(0)
  global Base=p[0.0,0.0,0.0,0.0,0.0,0.0]
  global stack_a=p[-0.5248255250200572,-0.5284374169385081,1.2123978574783925,-1.484264308398049,0.6068351379254189,-0.6065749598559471]
  global stack_b=p[-0.5414774169528097,-0.5058673807060519,1.26412428543644,-1.489782507816834,0.5593241591641521,-0.580462218488525]
  rtde_set_watchdog("speed_slider_mask", 10.0, "pause")
  global last_task=0
  global print1=  False  
  global print2=  False  
  global print3=  False  
  global print_enable=  False  
  global vision_pos=p[0,0,0,0,0,0]
  def PreTask():
    $ 47 "PreTask" "noBreak"
    $ 48 "If  not (gantry_in_pos_a xor gantry_in_pos_b)"
    if (  not  (read_input_boolean_register(5)  xor  read_input_boolean_register(6))):
      $ 49 "Popup: Err: Gantry not in pos"
      popup("Err: Gantry not in pos", "Warning", True, False, blocking=True)
    end
    $ 50 "If gantry_in_pos_a"
    if (read_input_boolean_register(5)):
      $ 51 "reference≔pose_add(stack_a, stack_a_to_ref)"
      global reference= pose_add (stack_a, stack_a_to_ref)
    else:
      $ 52 "ElseIf gantry_in_pos_b"
      if (read_input_boolean_register(6)):
        $ 53 "reference≔pose_add(stack_b, stack_b_to_ref)"
        global reference= pose_add (stack_b, stack_b_to_ref)
      end
    end
    $ 54 "'Where is the miminimum Z relative to current pos'"
    # 'Where is the miminimum Z relative to current pos'
    $ 55 "vision_pos_ex≔pose_trans(pose_inv(reference), get_actual_tcp_pose())"
    global vision_pos_ex= pose_trans ( pose_inv (reference),  get_actual_tcp_pose ())
    $ 56 "vision_pos_ex≔pose_add(vision_pos_ex, p[0, 0, 2*clearance + Z_MIN/1000 - vision_pos_ex[2], 0, 0, 0])"
    global vision_pos_ex= pose_add (vision_pos_ex, p[0, 0, 2*clearance + read_input_integer_register(6)/1000 - vision_pos_ex[2], 0, 0, 0])
    $ 57 "CLEAR≔pose_trans(reference, vision_pos_ex)"
    global CLEAR= pose_trans (reference, vision_pos_ex)
  end
  def MoveHome():
    $ 58 "MoveHome" "noBreak"
    $ 59 "Set current_task=0"
    write_output_integer_register(0, 0)
    $ 60 "Set task_done=Off"
    write_output_boolean_register(3, False)
    $ 61 "Set task_active=Off"
    write_output_boolean_register(2, False)
    $ 62 "If  not homed"
    if (  not  read_output_boolean_register(1)):
      $ 63 "Set moving_home=On"
      write_output_boolean_register(0, True)
      $ 64 "MoveL"
      $ 65 "home" "breakAfter"
      global move_thread_flag_65=0
      thread move_thread_65():
        enter_critical
        move_thread_flag_65 = 1
        movel(pose_trans(Base, p[-0.3585273863287797,-0.3745525568107262,0.7634990209927934,-0.6809851524142984,-1.676347047244469,1.750266339878694]), a=0.1, v=0.1, r=0.05)
        move_thread_flag_65 = 2
        exit_critical
      end
      move_thread_flag_65 = 0
      move_thread_han_65 = run move_thread_65()
      while (True):
        sleep(1.0E-10)
        if (move_thread_flag_65 > 1):
          join move_thread_han_65
          $ 66 "Until (reached_waypoint)"
          $ 67 "Set homed=On"
          write_output_boolean_register(1, True)
          break
        end
        sync()
      end
      $ 68 "Set moving_home=Off"
      write_output_boolean_register(0, False)
    end
  end
  def StartTask():
    $ 69 "StartTask" "noBreak"
    $ 70 "Set current_task=task"
    write_output_integer_register(0, read_input_integer_register(0))
    $ 71 "Set task_active=On"
    write_output_boolean_register(2, True)
  end
  def SetWaypoints():
    $ 72 "SetWaypoints" "noBreak"
    $ 73 "Set Ordering"
    $ 74 "B2≔p[X2/1000, Y/1000, Z/1000, 0, 0, 0]"
    global B2=p[read_input_integer_register(2)/1000, read_input_integer_register(4)/1000, read_input_integer_register(5)/1000, 0, 0, 0]
    $ 75 "If current_task≟TE_L2R"
    if (read_output_integer_register(0) == TE_L2R):
      $ 76 "'Left to right (+ive)'"
      # 'Left to right (+ive)'
      $ 77 "xm≔1"
      global xm=1
      $ 78 "B1≔p[X1/1000, Y/1000, Z/1000, 0, 0, 0]"
      global B1=p[read_input_integer_register(1)/1000, read_input_integer_register(4)/1000, read_input_integer_register(5)/1000, 0, 0, 0]
      $ 79 "B3≔p[X3/1000, Y/1000, Z/1000, 0, 0, 0]"
      global B3=p[read_input_integer_register(3)/1000, read_input_integer_register(4)/1000, read_input_integer_register(5)/1000, 0, 0, 0]
    else:
      $ 80 "ElseIf current_task≟TE_R2L"
      if (read_output_integer_register(0) == TE_R2L):
        $ 81 "'Right to left (-ive)'"
        # 'Right to left (-ive)'
        $ 82 "xm≔-1"
        global xm=-1
        $ 83 "B1≔p[X3/1000, Y/1000, Z/1000, 0, 0, 0]"
        global B1=p[read_input_integer_register(3)/1000, read_input_integer_register(4)/1000, read_input_integer_register(5)/1000, 0, 0, 0]
        $ 84 "B3≔p[X1/1000, Y/1000, Z/1000, 0, 0, 0]"
        global B3=p[read_input_integer_register(1)/1000, read_input_integer_register(4)/1000, read_input_integer_register(5)/1000, 0, 0, 0]
      end
    end
    $ 85 "Print Area Vars"
    $ 86 "'Move the print areas relative to given box'"
    # 'Move the print areas relative to given box'
    $ 87 "'Do not overrwrite these'"
    # 'Do not overrwrite these'
    $ 88 "PA1≔pose_add(B1, box_to_pa_XY)"
    global PA1= pose_add (B1, box_to_pa_XY)
    $ 89 "PA2≔pose_add(B2, box_to_pa_XY)"
    global PA2= pose_add (B2, box_to_pa_XY)
    $ 90 "PA3≔pose_add(B3, box_to_pa_XY)"
    global PA3= pose_add (B3, box_to_pa_XY)
    $ 91 "Calculate Waypoints"
    $ 92 "PA1_EN≔pose_add(PA1, p[-runover*xm, 0, clearance, 0, d2r(stack_ry), 0])"
    global PA1_EN= pose_add (PA1, p[-runover*xm, 0, clearance, 0,  d2r (stack_ry), 0])
    $ 93 "PA3_EX≔pose_add(PA3, p[+runover*xm, 0, clearance, 0, d2r(stack_ry), 0])"
    global PA3_EX= pose_add (PA3, p[+runover*xm, 0, clearance, 0,  d2r (stack_ry), 0])
    $ 94 "APPROACH≔pose_add(PA1_EN, p[0, 0, 2*clearance + Z_MIN/1000 - PA1_EN[2], 0, 0, 0])"
    global APPROACH= pose_add (PA1_EN, p[0, 0, 2*clearance + read_input_integer_register(6)/1000 - PA1_EN[2], 0, 0, 0])
    $ 95 "Reference Base"
    $ 96 "PA1_EN≔pose_trans(reference, PA1_EN)"
    global PA1_EN= pose_trans (reference, PA1_EN)
    $ 97 "PA3_EX≔pose_trans(reference, PA3_EX)"
    global PA3_EX= pose_trans (reference, PA3_EX)
    $ 98 "APPROACH≔pose_trans(reference, APPROACH)"
    global APPROACH= pose_trans (reference, APPROACH)
  end
  def MoveWaypoints():
    $ 99 "MoveWaypoints" "noBreak"
    $ 100 "'Minimum z position above entry'"
    # 'Minimum z position above entry'
    $ 101 "If homed"
    if (read_output_boolean_register(1)):
      $ 102 "MoveL"
      $ 103 "Set homed= False "
      write_output_boolean_register(1,   False  )
      $ 104 "APPROACH" "breakAfter"
      global move_thread_flag_104=0
      thread move_thread_104():
        enter_critical
        move_thread_flag_104 = 1
        movel(pose_trans(Base, APPROACH), a=0.1, v=0.1, r=0.01)
        move_thread_flag_104 = 2
        exit_critical
      end
      move_thread_flag_104 = 0
      move_thread_han_104 = run move_thread_104()
      while (True):
        if (read_input_boolean_register(4)):
          kill move_thread_han_104
          stopl(0.1)
          $ 105 "Until (expression)"
          break
        end
        sleep(1.0E-10)
        if (move_thread_flag_104 > 1):
          join move_thread_han_104
          break
        end
        sync()
      end
      $ 106 "PA1_EN" "breakAfter"
      global move_thread_flag_106=0
      thread move_thread_106():
        enter_critical
        move_thread_flag_106 = 1
        movel(pose_trans(Base, PA1_EN), a=0.1, v=0.1, r=0.01)
        move_thread_flag_106 = 2
        exit_critical
      end
      move_thread_flag_106 = 0
      move_thread_han_106 = run move_thread_106()
      while (True):
        if (read_input_boolean_register(4)):
          kill move_thread_han_106
          stopl(0.1)
          $ 107 "Until (expression)"
          break
        end
        sleep(1.0E-10)
        if (move_thread_flag_106 > 1):
          join move_thread_han_106
          break
        end
        sync()
      end
    else:
      $ 108 "ElseIf resume_task"
      if (resume_task):
        $ 109 "'Resume from current position'"
        # 'Resume from current position'
        $ 110 "Set homed= False "
        write_output_boolean_register(1,   False  )
        $ 111 "resume_task≔ False "
        global resume_task=  False  
      else:
        $ 112 "ElseIf last_task≟TE_L2R and current_task≟TE_R2L and  not restart_task"
        if (last_task == TE_L2R  and  read_output_integer_register(0) == TE_R2L  and    not  restart_task):
          $ 113 "MoveL"
          $ 114 "Set homed= False "
          write_output_boolean_register(1,   False  )
          $ 115 "PA1_EN" "breakAfter"
          global move_thread_flag_115=0
          thread move_thread_115():
            enter_critical
            move_thread_flag_115 = 1
            movel(pose_trans(Base, PA1_EN), a=0.1, v=0.1, r=0.01)
            move_thread_flag_115 = 2
            exit_critical
          end
          move_thread_flag_115 = 0
          move_thread_han_115 = run move_thread_115()
          while (True):
            if (read_input_boolean_register(4)):
              kill move_thread_han_115
              stopl(0.1)
              $ 116 "Until (expression)"
              break
            end
            sleep(1.0E-10)
            if (move_thread_flag_115 > 1):
              join move_thread_han_115
              break
            end
            sync()
          end
        else:
          $ 117 "Else" "noBreak"
          $ 118 "restart_task≔ False "
          global restart_task=  False  
          $ 119 "MoveL"
          $ 120 "Set homed= False "
          write_output_boolean_register(1,   False  )
          $ 121 "CLEAR" "breakAfter"
          global move_thread_flag_121=0
          thread move_thread_121():
            enter_critical
            move_thread_flag_121 = 1
            movel(pose_trans(Base, CLEAR), a=0.1, v=0.1, r=0.01)
            move_thread_flag_121 = 2
            exit_critical
          end
          move_thread_flag_121 = 0
          move_thread_han_121 = run move_thread_121()
          while (True):
            if (read_input_boolean_register(4)):
              kill move_thread_han_121
              stopl(0.1)
              $ 122 "Until (expression)"
              break
            end
            sleep(1.0E-10)
            if (move_thread_flag_121 > 1):
              join move_thread_han_121
              break
            end
            sync()
          end
          $ 123 "APPROACH" "breakAfter"
          global move_thread_flag_123=0
          thread move_thread_123():
            enter_critical
            move_thread_flag_123 = 1
            movel(pose_trans(Base, APPROACH), a=0.1, v=0.1, r=0.01)
            move_thread_flag_123 = 2
            exit_critical
          end
          move_thread_flag_123 = 0
          move_thread_han_123 = run move_thread_123()
          while (True):
            if (read_input_boolean_register(4)):
              kill move_thread_han_123
              stopl(0.1)
              $ 124 "Until (expression)"
              break
            end
            sleep(1.0E-10)
            if (move_thread_flag_123 > 1):
              join move_thread_han_123
              break
            end
            sync()
          end
          $ 125 "PA1_EN" "breakAfter"
          global move_thread_flag_125=0
          thread move_thread_125():
            enter_critical
            move_thread_flag_125 = 1
            movel(pose_trans(Base, PA1_EN), a=0.1, v=0.1, r=0.01)
            move_thread_flag_125 = 2
            exit_critical
          end
          move_thread_flag_125 = 0
          move_thread_han_125 = run move_thread_125()
          while (True):
            if (read_input_boolean_register(4)):
              kill move_thread_han_125
              stopl(0.1)
              $ 126 "Until (expression)"
              break
            end
            sleep(1.0E-10)
            if (move_thread_flag_125 > 1):
              join move_thread_han_125
              break
            end
            sync()
          end
        end
      end
    end
    $ 127 "'Move Across'"
    # 'Move Across'
    $ 128 "MoveL"
    $ 129 "print_enable≔ True "
    global print_enable=  True  
    $ 130 "PA3_EX" "breakAfter"
    global move_thread_flag_130=0
    thread move_thread_130():
      enter_critical
      move_thread_flag_130 = 1
      movel(pose_trans(Base, PA3_EX), a=0.5, v=0.1)
      move_thread_flag_130 = 2
      exit_critical
    end
    move_thread_flag_130 = 0
    move_thread_han_130 = run move_thread_130()
    while (True):
      if (read_input_boolean_register(4)):
        kill move_thread_han_130
        stopl(0.5)
        $ 131 "Until (expression)"
        break
      end
      sleep(1.0E-10)
      if (move_thread_flag_130 > 1):
        join move_thread_han_130
        break
      end
      sync()
    end
    $ 132 "print_enable≔ False "
    global print_enable=  False  
  end
  def FinishTask():
    $ 133 "FinishTask" "noBreak"
    $ 134 "'Acknowledgement sequence with PLC'"
    # 'Acknowledgement sequence with PLC'
    $ 135 "last_task≔current_task"
    global last_task=read_output_integer_register(0)
    $ 136 "Set task_active=Off"
    write_output_boolean_register(2, False)
    $ 137 "Set task_done=On"
    write_output_boolean_register(3, True)
    $ 138 "Wait task≟0 or cancel_home"
    while (not(read_input_integer_register(0) == 0  or  read_input_boolean_register(4))):
      sync()
    end
    $ 139 "Set current_task=0"
    write_output_integer_register(0, 0)
    $ 140 "Set task_done=Off"
    write_output_boolean_register(3, False)
  end
  $ 2 "BeforeStart"
  $ 3 "Script: readme.script"
  # SETUP INFO
  # 1. Configure TCP
  # 2. Calibrate vision planes A and B
  # 3. Set the home position
  # 4. Set variables at setup
  
  # stack_ry - corresponds to tool rotation vector relative to stack
  # print_width - width of the print label
  # printer_width - width of the printer head
  # ramp_distance - how far to reach constant speed
  # clearance - how far away are we printing from the stack
  # box_to_PA_XY - box coord to print area
  # stack_a_to_ref, stack_b_to_ref - adjusts the vision plane calibration discrepancies
  # TE_L2R - Task enum left to right
  $ 4 "Script: utils.script"
  def Max(a, b):
    if (a >= b):
      return a
    else:
      return b
    end
  end
  
  
  def Min(a, b):
    if (a <= b):
      return a
    else:
      return b
    end
  end
  $ 5 "Config"
  $ 6 "'The tcp rotation components relative to stack'"
  # 'The tcp rotation components relative to stack'
  $ 7 "stack_ry≔-180"
  global stack_ry=-180
  $ 8 "print_width≔0.04"
  global print_width=0.04
  $ 9 "printer_width≔0.125"
  global printer_width=0.125
  $ 10 "ramp_dist≔0.05"
  global ramp_dist=0.05
  $ 11 "clearance≔0.04"
  global clearance=0.04
  $ 12 "box_to_pa_XY≔p[0.0325, -0.05, 0, 0, 0, 0]"
  global box_to_pa_XY=p[0.0325, -0.05, 0, 0, 0, 0]
  $ 13 "stack_a_to_ref≔p[0, 0, 0, 0, 0, 0]"
  global stack_a_to_ref=p[0, 0, 0, 0, 0, 0]
  $ 14 "stack_b_to_ref≔p[0, 0, 0, 0, 0, 0]"
  global stack_b_to_ref=p[0, 0, 0, 0, 0, 0]
  $ 15 "TE_L2R≔1"
  global TE_L2R=1
  $ 16 "TE_R2L≔2"
  global TE_R2L=2
  $ 17 "Config Calcs"
  $ 18 "print_range≔(print_width+printer_width)/2"
  global print_range=(print_width+printer_width)/2
  $ 19 "runover≔print_range+ramp_dist"
  global runover=print_range+ramp_dist
  $ 20 "Restart Checks"
  $ 21 "tasks_equal≔task≟current_task"
  global tasks_equal=read_input_integer_register(0) == read_output_integer_register(0)
  $ 22 "tasks_printing≔task≠0 and current_task≠0 and print_enable"
  global tasks_printing=read_input_integer_register(0) != 0  and  read_output_integer_register(0) != 0  and  print_enable
  $ 23 "resume_task≔start_continue and tasks_equal and tasks_printing"
  global resume_task=read_input_boolean_register(2)  and  tasks_equal  and  tasks_printing
  $ 24 "restart_task≔start_retry and ( not resume_task) and tasks_printing"
  global restart_task=read_input_boolean_register(3)  and  (  not  resume_task)  and  tasks_printing
  $ 25 "print_enable≔ False "
  global print_enable=  False  
  $ 26 "Keep current pos as home"
  $ 27 "sp≔get_actual_joint_positions()"
  global sp= get_actual_joint_positions ()
  $ 28 "MoveJ"
  $ 29 "sp" "breakAfter"
  movej(sp, a=1.3962634015954636, v=1.0471975511965976)
  $ 30 "Reset bits"
  $ 31 "Set task_done=Off"
  write_output_boolean_register(3, False)
  $ 32 "Set task_active=Off"
  write_output_boolean_register(2, False)
  $ 33 "Set current_task=0"
  write_output_integer_register(0, 0)
  $ 34 "Set homed=Off"
  write_output_boolean_register(1, False)
  $ 35 "Set moving_home=Off"
  write_output_boolean_register(0, False)
  $ 141 "Thread_1"
  thread Thread_1():
    while (True):
      $ 142 "'Monitors X position for printing'"
      # 'Monitors X position for printing'
      $ 143 "If print_enable"
      if (print_enable):
        $ 144 "vision_pos≔pose_trans(pose_inv(reference), get_actual_tcp_pose())"
        global vision_pos= pose_trans ( pose_inv (reference),  get_actual_tcp_pose ())
        $ 145 "print1≔norm(vision_pos[0] - PA1[0]) ≤ print_range"
        global print1=norm(vision_pos[0] - PA1[0])  <=  print_range
        $ 146 "print2≔norm(vision_pos[0] - PA2[0]) ≤ print_range"
        global print2=norm(vision_pos[0] - PA2[0])  <=  print_range
        $ 147 "print3≔norm(vision_pos[0] - PA3[0]) ≤ print_range"
        global print3=norm(vision_pos[0] - PA3[0])  <=  print_range
      end
      $ 148 "Set printing=(print1 or print2 or print3) and print_enable"
      write_output_boolean_register(4, (print1  or  print2  or  print3)  and  print_enable)
      $ 149 "sync()"
      sync()
    end
  end
  threadId_Thread_1 = run Thread_1()
  while (True):
    $ 36 "Robot Program"
    $ 37 "If gantry_in_pos_a or gantry_in_pos_b"
    if (read_input_boolean_register(5)  or  read_input_boolean_register(6)):
      $ 38 "If cancel_home"
      if (read_input_boolean_register(4)):
        $ 39 "Call PreTask"
        PreTask()
        $ 40 "Call MoveHome"
        MoveHome()
      else:
        $ 41 "ElseIf task≟TE_L2R or task≟TE_R2L"
        if (read_input_integer_register(0) == TE_L2R  or  read_input_integer_register(0) == TE_R2L):
          $ 42 "Call PreTask"
          PreTask()
          $ 43 "Call StartTask"
          StartTask()
          $ 44 "Call SetWaypoints"
          SetWaypoints()
          $ 45 "Call MoveWaypoints"
          MoveWaypoints()
          $ 46 "Call FinishTask"
          FinishTask()
        end
      end
    end
  end
end
