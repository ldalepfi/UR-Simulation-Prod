 Program
   Init Variables
   BeforeStart
     Script: readme.script
     Script: utils.script
     Config
       'The tcp rotation components relative to stack'
       stack_ry≔-180
       print_width≔0.04
       printer_width≔0.125
       ramp_dist≔0.05
       clearance≔0.04
       box_to_pa_XY≔p[0.0325, -0.05, 0, 0, 0, 0]
       stack_a_to_ref≔p[0, 0, 0, 0, 0, 0]
       stack_b_to_ref≔p[0, 0, 0, 0, 0, 0]
       TE_L2R≔1
       TE_R2L≔2
     Config Calcs
       print_range≔(print_width+printer_width)/2
       runover≔print_range+ramp_dist
     Restart Checks
       tasks_equal≔task≟current_task
       tasks_printing≔task≠0 and current_task≠0 and print_enable
       resume_task≔start_continue and tasks_equal and tasks_printing
       restart_task≔start_retry and ( not resume_task) and tasks_printing
       print_enable≔ False 
     Keep current pos as home
       sp≔get_actual_joint_positions()
       MoveJ
         sp
     Reset bits
       Set task_done=Off
       Set task_active=Off
       Set current_task=0
       Set homed=Off
       Set moving_home=Off
   Robot Program
     If gantry_in_pos_a or gantry_in_pos_b
       If cancel_home
         Call PreTask
         Call MoveHome
       ElseIf task≟TE_L2R or task≟TE_R2L
         Call PreTask
         Call StartTask
         Call SetWaypoints
         Call MoveWaypoints
         Call FinishTask
   PreTask
     If  not (gantry_in_pos_a xor gantry_in_pos_b)
       Popup: Err: Gantry not in pos
     If gantry_in_pos_a
       reference≔pose_add(stack_a, stack_a_to_ref)
     ElseIf gantry_in_pos_b
       reference≔pose_add(stack_b, stack_b_to_ref)
     'Where is the miminimum Z relative to current pos'
     vision_pos_ex≔pose_trans(pose_inv(reference), get_actual_tcp_pose())
     vision_pos_ex≔pose_add(vision_pos_ex, p[0, 0, 2*clearance + Z_MIN/1000 - vision_pos_ex[2], 0, 0, 0])
     CLEAR≔pose_trans(reference, vision_pos_ex)
   MoveHome
     Set current_task=0
     Set task_done=Off
     Set task_active=Off
     If  not homed
       Set moving_home=On
       MoveL
         home
           Until (reached_waypoint)
             Set homed=On
       Set moving_home=Off
   StartTask
     Set current_task=task
     Set task_active=On
   SetWaypoints
     Set Ordering
       B2≔p[X2/1000, Y/1000, Z/1000, 0, 0, 0]
       If current_task≟TE_L2R
         'Left to right (+ive)'
         xm≔1
         B1≔p[X1/1000, Y/1000, Z/1000, 0, 0, 0]
         B3≔p[X3/1000, Y/1000, Z/1000, 0, 0, 0]
       ElseIf current_task≟TE_R2L
         'Right to left (-ive)'
         xm≔-1
         B1≔p[X3/1000, Y/1000, Z/1000, 0, 0, 0]
         B3≔p[X1/1000, Y/1000, Z/1000, 0, 0, 0]
     Print Area Vars
       'Move the print areas relative to given box'
       'Do not overrwrite these'
       PA1≔pose_add(B1, box_to_pa_XY)
       PA2≔pose_add(B2, box_to_pa_XY)
       PA3≔pose_add(B3, box_to_pa_XY)
     Calculate Waypoints
       PA1_EN≔pose_add(PA1, p[-runover*xm, 0, clearance, 0, d2r(stack_ry), 0])
       PA3_EX≔pose_add(PA3, p[+runover*xm, 0, clearance, 0, d2r(stack_ry), 0])
       APPROACH≔pose_add(PA1_EN, p[0, 0, 2*clearance + Z_MIN/1000 - PA1_EN[2], 0, 0, 0])
     Reference Base
       PA1_EN≔pose_trans(reference, PA1_EN)
       PA3_EX≔pose_trans(reference, PA3_EX)
       APPROACH≔pose_trans(reference, APPROACH)
   MoveWaypoints
     'Minimum z position above entry'
     If homed
       MoveL
         Set homed= False 
         APPROACH
           Until (expression)
         PA1_EN
           Until (expression)
     ElseIf resume_task
       'Resume from current position'
       Set homed= False 
       resume_task≔ False 
     ElseIf last_task≟TE_L2R and current_task≟TE_R2L and  not restart_task
       MoveL
         Set homed= False 
         PA1_EN
           Until (expression)
     Else
       restart_task≔ False 
       MoveL
         Set homed= False 
         CLEAR
           Until (expression)
         APPROACH
           Until (expression)
         PA1_EN
           Until (expression)
     'Move Across'
     MoveL
       print_enable≔ True 
       PA3_EX
         Until (expression)
       print_enable≔ False 
   FinishTask
     'Acknowledgement sequence with PLC'
     last_task≔current_task
     Set task_active=Off
     Set task_done=On
     Wait task≟0 or cancel_home
     Set current_task=0
     Set task_done=Off
   Thread_1
     'Monitors X position for printing'
     If print_enable
       vision_pos≔pose_trans(pose_inv(reference), get_actual_tcp_pose())
       print1≔norm(vision_pos[0] - PA1[0]) ≤ print_range
       print2≔norm(vision_pos[0] - PA2[0]) ≤ print_range
       print3≔norm(vision_pos[0] - PA3[0]) ≤ print_range
     Set printing=(print1 or print2 or print3) and print_enable
     sync()
